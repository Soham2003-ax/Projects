# -*- coding: utf-8 -*-
"""Ml project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k1TkQBK04bjhg3H4EkNh8VD5xnvdBM2U
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

data=pd.read_csv("/content/sample_data/ml project.csv")
data.head()

data.shape

print(data.isna().sum())

print(data.info())

data.columns

data['TotalPrice'] = data['Quantity'] * data['UnitPrice']
data['InvoiceDate'] = pd.to_datetime(data['InvoiceDate'], errors='coerce')
data['HighValue'] = data['TotalPrice'].apply(lambda x: 1 if x > 100 else 0)

# # Define the function
# def classify_transaction(x):
#     if x > 100:
#         return 1
#     else:
#         return 0

# # Apply the function
# data['HighValue'] = data['TotalPrice'].apply(classify_transaction)

data.dropna(subset=['CustomerID', 'InvoiceDate', 'Description'], inplace=True)

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
data['Country'] = encoder.fit_transform(data['Country'])
data['Description'] = encoder.fit_transform(data['Description'])

df = data[['Quantity', 'UnitPrice', 'TotalPrice', 'CustomerID', 'Country', 'Description', 'HighValue']]

plt.boxplot(df['Quantity'])
plt.title("Quantity Boxplot")
plt.show()

plt.boxplot(df['UnitPrice'])
plt.title("UnitPrice Boxplot")
plt.show()

corr_matrix = df.drop(columns=['HighValue']).corr()
sns.heatmap(corr_matrix, annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.show()

from sklearn.preprocessing import MinMaxScaler
X = df.drop(columns=['HighValue'])
y = df['HighValue']
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)

from sklearn.model_selection import train_test_split
xtrain, xtest, ytrain, ytest = train_test_split(X_scaled, y, test_size=0.2, random_state=27, stratify=y)

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score, f1_score, classification_report

Knn = KNeighborsClassifier()
Knn.fit(xtrain, ytrain)
predict = Knn.predict(xtest)
print("KNN Accuracy:", accuracy_score(ytest, predict))

for k in range(1, 20, 2):
    knn = KNeighborsClassifier(n_neighbors=k)
    knn.fit(xtrain, ytrain)
    predict = knn.predict(xtest)
    print(f"k={k} Accuracy={accuracy_score(ytest, predict)}")

from sklearn.linear_model import LogisticRegression
Log = LogisticRegression(max_iter=500)
Log.fit(xtrain, ytrain)
Logpred = Log.predict(xtest)
print("Logistic Regression Accuracy:", accuracy_score(ytest, Logpred))
print("Confusion Matrix:\n", confusion_matrix(ytest, Logpred))
print("Precision:", precision_score(ytest, Logpred))
print("Recall:", recall_score(ytest, Logpred))
print("F1 Score:", f1_score(ytest, Logpred))
print("Classification Report:\n", classification_report(ytest, Logpred))

from sklearn.linear_model import LogisticRegression
Log = LogisticRegression(max_iter=500, class_weight='balanced')
Log.fit(xtrain, ytrain)
Logpred = Log.predict(xtest)
print("Logistic Regression Accuracy:", accuracy_score(ytest, Logpred))
print("Confusion Matrix:\n", confusion_matrix(ytest, Logpred))
print("Precision:", precision_score(ytest, Logpred))
print("Recall:", recall_score(ytest, Logpred))
print("F1 Score:", f1_score(ytest, Logpred))
print("Classification Report:\n", classification_report(ytest, Logpred))

from sklearn.model_selection import GridSearchCV

param_grid = {
    'n_neighbors': [5, 7, 9],
    'weights': ['uniform', 'distance'],
    'algorithm': ['auto', 'ball_tree', 'kd_tree', 'brute']
}
gsv = GridSearchCV(KNeighborsClassifier(), param_grid, n_jobs=-1, refit=True, verbose=1)
gsv.fit(xtrain, ytrain)
best_pred = gsv.predict(xtest)

print("Best KNN Params:", gsv.best_params_)
print("Best KNN Accuracy:", accuracy_score(ytest, best_pred))

decison treeregressor knn regressosr MSE MAE R2 score